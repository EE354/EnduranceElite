import { SESSION_COOKIE_NAME, createSessionCookie } from "./cookie.js";
import { logError } from "../utils/log.js";
import { generateHashWithScrypt, validateScryptHash } from "../utils/crypto.js";
import { generateRandomString } from "../utils/nanoid.js";
import { LuciaError } from "./error.js";
import { parseCookie } from "../utils/cookie.js";
import { validateDatabaseSession } from "./session.js";
import { transformDatabaseKey, getOneTimeKeyExpiration } from "./key.js";
import { isWithinExpiration } from "../utils/date.js";
import { AuthRequest } from "./request.js";
import { lucia as defaultMiddleware } from "../middleware/index.js";
export const lucia = (config) => {
	return new Auth(config);
};
const validateConfiguration = (config) => {
	const adapterProvided = config.adapter;
	if (!adapterProvided) {
		logError('Adapter is not defined in configuration ("config.adapter")');
		process.exit(1);
	}
};
export class Auth {
	adapter;
	generateUserId;
	sessionCookieOption;
	sessionExpiresIn;
	env;
	hash;
	autoDatabaseCleanup;
	middleware;
	csrfProtection;
	origin;
	constructor(config) {
		validateConfiguration(config);
		const defaultSessionCookieOption = {
			sameSite: "lax",
			path: "/"
		};
		if ("user" in config.adapter) {
			let userAdapter = config.adapter.user(LuciaError);
			let sessionAdapter = config.adapter.session(LuciaError);
			if ("getSessionAndUserBySessionId" in userAdapter) {
				const { getSessionAndUserBySessionId: _, ...extractedUserAdapter } =
					userAdapter;
				userAdapter = extractedUserAdapter;
			}
			if ("getSessionAndUserBySessionId" in sessionAdapter) {
				const { getSessionAndUserBySessionId: _, ...extractedSessionAdapter } =
					sessionAdapter;
				sessionAdapter = extractedSessionAdapter;
			}
			this.adapter = {
				...userAdapter,
				...sessionAdapter
			};
		} else {
			this.adapter = config.adapter(LuciaError);
		}
		this.generateUserId =
			config.generateCustomUserId ?? (() => generateRandomString(15));
		this.env = config.env;
		this.csrfProtection = config.csrfProtection ?? true;
		this.sessionExpiresIn = {
			activePeriod:
				config.sessionExpiresIn?.activePeriod ?? 1000 * 60 * 60 * 24,
			idlePeriod:
				config.sessionExpiresIn?.idlePeriod ?? 1000 * 60 * 60 * 24 * 14
		};
		this.autoDatabaseCleanup = config.autoDatabaseCleanup ?? true;
		this._transformDatabaseUser = (databaseUser) => {
			const defaultTransform = ({ id }) => {
				return {
					userId: id
				};
			};
			const transform = config.transformDatabaseUser ?? defaultTransform;
			return transform(databaseUser);
		};
		this.sessionCookieOption =
			config.sessionCookie ?? defaultSessionCookieOption;
		this.hash = {
			generate: config.hash?.generate ?? generateHashWithScrypt,
			validate: config.hash?.validate ?? validateScryptHash
		};
		this.middleware = config.middleware ?? defaultMiddleware();
		this.origin = config.origin ?? [];
	}
	_transformDatabaseUser;
	transformDatabaseUser = (databaseUser) => {
		return this._transformDatabaseUser(databaseUser);
	};
	getUser = async (userId) => {
		const databaseUser = await this.adapter.getUser(userId);
		if (!databaseUser) throw new LuciaError("AUTH_INVALID_USER_ID");
		const user = this.transformDatabaseUser(databaseUser);
		return user;
	};
	getSessionUser = async (sessionId) => {
		if (sessionId.length !== 40)
			throw new LuciaError("AUTH_INVALID_SESSION_ID");
		let databaseUser;
		let sessionData;
		if (this.adapter.getSessionAndUserBySessionId !== undefined) {
			const databaseUserSession =
				await this.adapter.getSessionAndUserBySessionId(sessionId);
			if (!databaseUserSession) throw new LuciaError("AUTH_INVALID_SESSION_ID");
			databaseUser = databaseUserSession.user;
			sessionData = databaseUserSession.session;
		} else {
			sessionData = await this.adapter.getSession(sessionId);
			databaseUser = sessionData
				? await this.adapter.getUser(sessionData.user_id)
				: null;
		}
		if (!sessionData) throw new LuciaError("AUTH_INVALID_SESSION_ID");
		const session = validateDatabaseSession(sessionData);
		if (!session) {
			if (this.autoDatabaseCleanup) {
				await this.adapter.deleteSession(sessionId);
			}
			throw new LuciaError("AUTH_INVALID_SESSION_ID");
		}
		if (!databaseUser) throw new LuciaError("AUTH_INVALID_USER_ID");
		return {
			user: this.transformDatabaseUser(databaseUser),
			session
		};
	};
	createUser = async (data) => {
		const userId = await this.generateUserId();
		const userAttributes = data.attributes ?? {};
		if (data.primaryKey === null) {
			const databaseUser = await this.adapter.setUser(
				userId,
				userAttributes,
				null
			);
			const user = this.transformDatabaseUser(databaseUser);
			return user;
		}
		const keyId = `${data.primaryKey.providerId}:${data.primaryKey.providerUserId}`;
		const password = data.primaryKey.password;
		const hashedPassword = password ? await this.hash.generate(password) : null;
		const databaseUser = await this.adapter.setUser(userId, userAttributes, {
			id: keyId,
			user_id: userId,
			hashed_password: hashedPassword,
			primary_key: true,
			expires: null
		});
		const user = this.transformDatabaseUser(databaseUser);
		return user;
	};
	updateUserAttributes = async (userId, attributes) => {
		const [updatedDatabaseUser] = await Promise.all([
			this.adapter.updateUserAttributes(userId, attributes),
			this.autoDatabaseCleanup
				? await this.deleteDeadUserSessions(userId)
				: null
		]);
		if (updatedDatabaseUser)
			return this.transformDatabaseUser(updatedDatabaseUser);
		return await this.getUser(userId);
	};
	deleteUser = async (userId) => {
		await this.adapter.deleteSessionsByUserId(userId);
		await this.adapter.deleteKeysByUserId(userId);
		await this.adapter.deleteUser(userId);
	};
	useKey = async (providerId, providerUserId, password) => {
		const keyId = `${providerId}:${providerUserId}`;
		// TODO: remove check in v2
		const shouldDataBeDeleted = async (data) => {
			const persistentKey = data.expires === null;
			if (persistentKey) return false;
			if (data.hashed_password === null) return true;
			if (password === null) return false;
			return await this.hash.validate(password, data.hashed_password);
		};
		const databaseKeyData = await this.adapter.getKey(
			keyId,
			shouldDataBeDeleted
		);
		if (!databaseKeyData) throw new LuciaError("AUTH_INVALID_KEY_ID");
		try {
			const singleUse = !!databaseKeyData.expires;
			const hashedPassword = databaseKeyData.hashed_password;
			if (hashedPassword) {
				if (!password) throw new LuciaError("AUTH_INVALID_PASSWORD");
				if (!hashedPassword) throw new LuciaError("AUTH_INVALID_PASSWORD");
				if (hashedPassword.startsWith("$2a"))
					throw new LuciaError("AUTH_OUTDATED_PASSWORD");
				const validPassword = await this.hash.validate(
					password,
					hashedPassword
				);
				if (!validPassword) throw new LuciaError("AUTH_INVALID_PASSWORD");
			}
			if (singleUse) {
				const withinExpiration = isWithinExpiration(databaseKeyData.expires);
				if (!withinExpiration) throw new LuciaError("AUTH_EXPIRED_KEY");
				await this.adapter.deleteNonPrimaryKey(databaseKeyData.id);
			}
			const key = transformDatabaseKey(databaseKeyData);
			return key;
		} catch (e) {
			if (e instanceof LuciaError && e.message === "AUTH_EXPIRED_KEY") {
				await this.adapter.deleteNonPrimaryKey(databaseKeyData.id);
			}
			throw e;
		}
	};
	getSession = async (sessionId) => {
		if (sessionId.length !== 40)
			throw new LuciaError("AUTH_INVALID_SESSION_ID");
		const databaseSession = await this.adapter.getSession(sessionId);
		if (!databaseSession) throw new LuciaError("AUTH_INVALID_SESSION_ID");
		const session = validateDatabaseSession(databaseSession);
		if (!session) {
			if (this.autoDatabaseCleanup) {
				await this.adapter.deleteSession(sessionId);
			}
			throw new LuciaError("AUTH_INVALID_SESSION_ID");
		}
		return session;
	};
	getAllUserSessions = async (userId) => {
		// validate user id
		await this.getUser(userId);
		const databaseData = await this.adapter.getSessionsByUserId(userId);
		const validStoredUserSessions = databaseData
			.map((databaseSession) => {
				return validateDatabaseSession(databaseSession);
			})
			.filter((session) => session !== null);
		const deadStoredUserSessionIds = databaseData
			.map((databaseSession) => {
				return databaseSession.id;
			})
			.filter((sessionId) => {
				return !validStoredUserSessions.some(
					(validSession) => validSession.sessionId === sessionId
				);
			});
		if (deadStoredUserSessionIds.length > 0) {
			await Promise.all(
				deadStoredUserSessionIds.map((deadSessionId) =>
					this.adapter.deleteSession(deadSessionId)
				)
			);
		}
		return validStoredUserSessions;
	};
	validateSession = async (sessionId) => {
		const session = await this.getSession(sessionId);
		if (session.state === "active") return session;
		const renewedSession = await this.renewSession(sessionId);
		return renewedSession;
	};
	validateSessionUser = async (sessionId) => {
		const { session, user } = await this.getSessionUser(sessionId);
		if (session.state === "active") return { session, user };
		const renewedSession = await this.renewSession(sessionId);
		return {
			session: renewedSession,
			user
		};
	};
	generateSessionId = () => {
		const sessionId = generateRandomString(40);
		const activePeriodExpiresAt = new Date(
			new Date().getTime() + this.sessionExpiresIn.activePeriod
		);
		const idlePeriodExpiresAt = new Date(
			activePeriodExpiresAt.getTime() + this.sessionExpiresIn.idlePeriod
		);
		return [sessionId, activePeriodExpiresAt, idlePeriodExpiresAt];
	};
	createSession = async (userId) => {
		const [sessionId, activePeriodExpiresAt, idlePeriodExpiresAt] =
			this.generateSessionId();
		await Promise.all([
			this.adapter.setSession({
				id: sessionId,
				user_id: userId,
				active_expires: activePeriodExpiresAt.getTime(),
				idle_expires: idlePeriodExpiresAt.getTime()
			}),
			this.autoDatabaseCleanup
				? await this.deleteDeadUserSessions(userId)
				: null
		]);
		return {
			userId,
			activePeriodExpiresAt,
			sessionId,
			idlePeriodExpiresAt,
			state: "active",
			fresh: true
		};
	};
	renewSession = async (sessionId) => {
		if (sessionId.length !== 40)
			throw new LuciaError("AUTH_INVALID_SESSION_ID");
		const databaseSession = await this.adapter.getSession(sessionId);
		if (!databaseSession) throw new LuciaError("AUTH_INVALID_SESSION_ID");
		const session = validateDatabaseSession(databaseSession);
		if (!session) {
			if (this.autoDatabaseCleanup) {
				await this.adapter.deleteSession(sessionId);
			}
			throw new LuciaError("AUTH_INVALID_SESSION_ID");
		}
		const [renewedSession] = await Promise.all([
			await this.createSession(session.userId),
			this.autoDatabaseCleanup
				? await this.deleteDeadUserSessions(session.userId)
				: null
		]);
		return renewedSession;
	};
	invalidateSession = async (sessionId) => {
		await this.adapter.deleteSession(sessionId);
	};
	invalidateAllUserSessions = async (userId) => {
		await this.adapter.deleteSessionsByUserId(userId);
	};
	deleteDeadUserSessions = async (userId) => {
		const databaseSessions = await this.adapter.getSessionsByUserId(userId);
		const deadSessionIds = databaseSessions
			.filter((databaseSession) => {
				return validateDatabaseSession(databaseSession) === null;
			})
			.map((databaseSession) => databaseSession.id);
		if (deadSessionIds.length === 0) return;
		await Promise.all(
			deadSessionIds.map((deadSessionId) => {
				this.adapter.deleteSession(deadSessionId);
			})
		);
	};
	parseRequestHeaders = (request) => {
		const cookies = parseCookie(request.headers.cookie ?? "");
		const sessionId = cookies[SESSION_COOKIE_NAME] ?? null;
		if (request.method === null || request.url === null)
			throw new LuciaError("AUTH_INVALID_REQUEST");
		const csrfCheck =
			request.method.toUpperCase() !== "GET" &&
			request.method.toUpperCase() !== "HEAD";
		if (csrfCheck && this.csrfProtection) {
			const requestOrigin = request.headers.origin;
			if (!requestOrigin) throw new LuciaError("AUTH_INVALID_REQUEST");
			try {
				const url = new URL(request.url);
				if (![url.origin, ...this.origin].includes(requestOrigin))
					throw new LuciaError("AUTH_INVALID_REQUEST");
			} catch {
				// failed to parse url
				throw new LuciaError("AUTH_INVALID_REQUEST");
			}
		}
		return sessionId;
	};
	handleRequest = (...args) => {
		const middleware = this.middleware;
		return new AuthRequest(this, middleware(...[...args, this.env]));
	};
	createSessionCookie = (session) => {
		return createSessionCookie(session, this.env, this.sessionCookieOption);
	};
	createKey = async (userId, keyData) => {
		const keyId = `${keyData.providerId}:${keyData.providerUserId}`;
		let hashedPassword = null;
		if (keyData.password !== null) {
			hashedPassword = await this.hash.generate(keyData.password);
		}
		if (keyData.type === "persistent") {
			await this.adapter.setKey({
				id: keyId,
				user_id: userId,
				hashed_password: hashedPassword,
				primary_key: false,
				expires: null
			});
			return {
				type: "persistent",
				providerId: keyData.providerId,
				providerUserId: keyData.providerUserId,
				primary: false,
				passwordDefined: !!keyData.password,
				userId
			};
		}
		const expiresAt = getOneTimeKeyExpiration(keyData.expiresIn);
		if (!expiresAt) throw new TypeError();
		await this.adapter.setKey({
			id: keyId,
			user_id: userId,
			hashed_password: hashedPassword,
			primary_key: false,
			expires: expiresAt.getTime()
		});
		return {
			type: "single_use",
			providerId: keyData.providerId,
			providerUserId: keyData.providerUserId,
			userId,
			expiresAt,
			expired: !isWithinExpiration(keyData.expiresIn),
			passwordDefined: !!keyData.password
		};
	};
	deleteKey = async (providerId, providerUserId) => {
		const keyId = `${providerId}:${providerUserId}`;
		await this.adapter.deleteNonPrimaryKey(keyId);
	};
	getKey = async (providerId, providerUserId) => {
		const keyId = `${providerId}:${providerUserId}`;
		const shouldDataBeDeleted = async () => false;
		const databaseKey = await this.adapter.getKey(keyId, shouldDataBeDeleted);
		if (!databaseKey) throw new LuciaError("AUTH_INVALID_KEY_ID");
		const key = transformDatabaseKey(databaseKey);
		return key;
	};
	getAllUserKeys = async (userId) => {
		await this.getUser(userId);
		const databaseData = await this.adapter.getKeysByUserId(userId);
		return databaseData.map((val) => transformDatabaseKey(val));
	};
	updateKeyPassword = async (providerId, providerUserId, password) => {
		const keyId = `${providerId}:${providerUserId}`;
		let updatedDatabaseKey;
		if (password === null) {
			updatedDatabaseKey = await this.adapter.updateKeyPassword(keyId, null);
		} else {
			const hashedPassword = await this.hash.generate(password);
			updatedDatabaseKey = await this.adapter.updateKeyPassword(
				keyId,
				hashedPassword
			);
		}
		if (updatedDatabaseKey) return;
		await this.getKey(providerId, providerUserId);
	};
}
