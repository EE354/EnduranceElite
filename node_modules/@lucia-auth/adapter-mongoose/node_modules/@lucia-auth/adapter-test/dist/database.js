import { generateRandomString } from "lucia-auth";
import { typeError, valueError } from "./validate.js";
import "lucia-auth/polyfill/node";
export class Database {
    queryHandler;
    user = () => {
        return new User(this.queryHandler);
    };
    clear = async () => {
        await this.queryHandler.key?.clear();
        await this.queryHandler.session?.clear();
        await this.queryHandler.user?.clear();
    };
    constructor(queryHandler) {
        this.queryHandler = queryHandler;
    }
}
class Model {
    value;
    name;
    queryHandler;
    storeQueryHandler;
    parent;
    constructor(name, queryHandler, value, parent = []) {
        this.name = name;
        this.value = value;
        this.queryHandler = queryHandler;
        this.storeQueryHandler = queryHandler[name];
        this.parent = parent;
    }
    commit = async () => {
        for (const parentModel of this.parent) {
            await parentModel.commit();
        }
        await this.storeQueryHandler?.insert(this.value);
    };
    safeCompare = (target) => {
        if (typeof target !== "object" || target === null)
            throw typeError(target, "object");
        for (const [refKey, refValue] of Object.entries(this.value)) {
            if (target[refKey] !== refValue) {
                return false;
            }
        }
        return true;
    };
    compare = (target) => {
        const isEqual = this.safeCompare(target);
        if (isEqual)
            return;
        throw valueError(target, this.value, "Target was not the expected value");
    };
    find = (target) => {
        if (!Array.isArray(target)) {
            throw typeError(target, "array");
        }
        for (const value of target) {
            const isEqual = this.safeCompare(value);
            if (isEqual)
                return;
        }
        throw valueError(target, this.value, "Target did not include the expected value");
    };
    exists = async () => {
        const databaseData = (await this.storeQueryHandler?.get()) ?? [];
        const existsInDatabase = databaseData.some(this.safeCompare);
        if (existsInDatabase)
            return;
        console.log("target:");
        console.dir(this.value, {
            depth: null
        });
        console.log("store");
        console.dir(databaseData, {
            depth: null
        });
        throw new Error(`Target not found in store ${this.name}`);
    };
    notExits = async () => {
        const databaseData = (await this.storeQueryHandler?.get()) ?? [];
        const existsInDatabase = databaseData.some(this.safeCompare);
        if (!existsInDatabase)
            return;
        console.log("target:");
        console.dir(this.value, {
            depth: null
        });
        console.log("store");
        console.dir(databaseData, {
            depth: null
        });
        throw new Error(`Target found in store ${this.name}`);
    };
    update = (value) => {
        this.value = { ...this.value, ...value };
    };
}
class User extends Model {
    session = () => {
        return new Session(this.queryHandler, [this], {
            userId: this.value.id
        });
    };
    key = (option) => {
        return new Key(this.queryHandler, [this], {
            userId: this.value.id,
            ...option
        });
    };
    constructor(queryHandler, options) {
        const userId = options?.userId ?? generateRandomString(8);
        const username = options?.username ?? `user_${generateRandomString(4)}`;
        super("user", queryHandler, {
            id: userId,
            username
        });
    }
}
class Session extends Model {
    constructor(queryHandler, parent, options) {
        const activeExpires = new Date().getTime() + 1000 * 60 * 60 * 8;
        super("session", queryHandler, {
            user_id: options.userId,
            id: `at_${generateRandomString(40)}`,
            active_expires: activeExpires,
            idle_expires: activeExpires + 1000 * 60 * 60 * 24
        }, parent);
    }
}
class Key extends Model {
    constructor(queryHandler, parent, options) {
        const DURATION_SEC = 60 * 60;
        const oneTimeExpires = options.oneTime
            ? new Date().getTime() + DURATION_SEC * 1000
            : null;
        super("key", queryHandler, {
            id: `test:${options.userId}@example.com`,
            user_id: options.userId,
            primary_key: options.primary,
            hashed_password: options.passwordDefined ? "HASHED" : null,
            expires: oneTimeExpires
        }, parent);
    }
}
