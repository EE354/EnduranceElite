import {
  derived,
  readable,
  writable
} from "./chunk-2XIZ5LLL.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  attr_dev,
  beforeUpdate,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  construct_svelte_component_dev,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_current_component,
  get_store_value,
  globals,
  group_outros,
  identity,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  prop_dev,
  run_all,
  safe_not_equal,
  setContext,
  set_data_dev,
  set_store_value,
  set_style,
  space,
  text,
  tick,
  transition_in,
  transition_out,
  validate_each_argument,
  validate_slots,
  validate_store
} from "./chunk-PBX6AF7V.js";

// node_modules/@event-calendar/core/src/Calendar.svelte
import "C:/Users/paulh/OneDrive/Documents/GitHub/EnduranceElite/node_modules/@event-calendar/core/index.css";

// node_modules/@event-calendar/core/src/lib/utils.js
function assign(...args) {
  return Object.assign(...args);
}
function floor(value) {
  return Math.floor(value);
}
function min(...args) {
  return Math.min(...args);
}
function max(...args) {
  return Math.max(...args);
}
function isObject(test) {
  return typeof test === "object" && test !== null;
}
function symbol() {
  return Symbol("ec");
}

// node_modules/@event-calendar/core/src/lib/actions.js
function setContent(node, content) {
  let actions = {
    update(content2) {
      while (node.firstChild) {
        node.removeChild(node.lastChild);
      }
      if (!isObject(content2)) {
        node.innerText = content2;
      } else if (content2.domNodes) {
        for (let child of content2.domNodes) {
          node.appendChild(child);
        }
      } else if (content2.html) {
        node.innerHTML = content2.html;
      }
    }
  };
  actions.update(content);
  return actions;
}
function outsideEvent(node, type) {
  const handlePointerDown = (jsEvent) => {
    if (node && !node.contains(jsEvent.target)) {
      node.dispatchEvent(
        new CustomEvent(type + "outside", { detail: { jsEvent } })
      );
    }
  };
  document.addEventListener(type, handlePointerDown, true);
  return {
    destroy() {
      document.removeEventListener(type, handlePointerDown, true);
    }
  };
}

// node_modules/@event-calendar/core/src/lib/date.js
var DAY_IN_SECONDS = 86400;
function createDate(input = void 0) {
  if (input !== void 0) {
    return input instanceof Date ? _fromLocalDate(input) : _fromISOString(input);
  }
  return _fromLocalDate(/* @__PURE__ */ new Date());
}
function createDuration(input) {
  if (typeof input === "number") {
    input = { seconds: input };
  } else if (typeof input === "string") {
    let seconds = 0, exp = 2;
    for (let part of input.split(":", 3)) {
      seconds += parseInt(part, 10) * Math.pow(60, exp--);
    }
    input = { seconds };
  } else if (input instanceof Date) {
    input = { hours: input.getUTCHours(), minutes: input.getUTCMinutes(), seconds: input.getUTCSeconds() };
  }
  let weeks = input.weeks || input.week || 0;
  return {
    years: input.years || input.year || 0,
    months: input.months || input.month || 0,
    days: weeks * 7 + (input.days || input.day || 0),
    seconds: (input.hours || input.hour || 0) * 60 * 60 + (input.minutes || input.minute || 0) * 60 + (input.seconds || input.second || 0),
    inWeeks: !!weeks
  };
}
function cloneDate(date) {
  return new Date(date.getTime());
}
function addDuration(date, duration, x = 1) {
  date.setUTCFullYear(date.getUTCFullYear() + x * duration.years);
  let month = date.getUTCMonth() + x * duration.months;
  date.setUTCMonth(month);
  month %= 12;
  if (month < 0) {
    month += 12;
  }
  while (date.getUTCMonth() !== month) {
    subtractDay(date);
  }
  date.setUTCDate(date.getUTCDate() + x * duration.days);
  date.setUTCSeconds(date.getUTCSeconds() + x * duration.seconds);
  return date;
}
function subtractDuration(date, duration, x = 1) {
  return addDuration(date, duration, -x);
}
function addDay(date, x = 1) {
  date.setUTCDate(date.getUTCDate() + x);
  return date;
}
function subtractDay(date, x = 1) {
  return addDay(date, -x);
}
function setMidnight(date) {
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function toLocalDate(date) {
  return new Date(
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds()
  );
}
function toISOString(date) {
  return date.toISOString().substring(0, 19);
}
function formatRange(start, end, intl2) {
  if (start.getFullYear() !== end.getFullYear()) {
    return intl2.format(start) + " - " + intl2.format(end);
  }
  let diff2 = [];
  if (start.getMonth() !== end.getMonth()) {
    diff2.push("month");
  }
  if (start.getDate() !== end.getDate()) {
    diff2.push("day");
  }
  if (!diff2.length) {
    return intl2.format(start);
  }
  let opts1 = intl2.resolvedOptions();
  let opts2 = {};
  for (let key of diff2) {
    opts2[key] = opts1[key];
  }
  let intl22 = new Intl.DateTimeFormat(opts1.locale, opts2);
  let full1 = intl2.format(start);
  let full2 = intl2.format(end);
  let part1 = intl22.format(start);
  let part2 = intl22.format(end);
  let common = _commonChunks(full1, part1, full2, part2);
  if (common) {
    return common.head + part1 + " - " + part2 + common.tail;
  }
  return full1 + " - " + full2;
}
function datesEqual(date1, ...dates2) {
  return dates2.every((date2) => date1.getTime() === date2.getTime());
}
function nextClosestDay(date, day) {
  let diff2 = day - date.getUTCDay();
  date.setUTCDate(date.getUTCDate() + (diff2 >= 0 ? diff2 : diff2 + 7));
  return date;
}
function prevClosestDay(date, day) {
  let diff2 = day - date.getUTCDay();
  date.setUTCDate(date.getUTCDate() + (diff2 <= 0 ? diff2 : diff2 - 7));
  return date;
}
function noTimePart(date) {
  return typeof date === "string" && date.length <= 10;
}
function _fromLocalDate(date) {
  return new Date(Date.UTC(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds()
  ));
}
function _fromISOString(str) {
  const parts = str.match(/\d+/g);
  return new Date(Date.UTC(
    Number(parts[0]),
    Number(parts[1]) - 1,
    Number(parts[2]),
    Number(parts[3] || 0),
    Number(parts[4] || 0),
    Number(parts[5] || 0)
  ));
}
function _commonChunks(str1, substr1, str2, substr2) {
  let i = 0;
  while (i < str1.length) {
    let res1;
    [i, res1] = _cut(str1, substr1, i);
    if (!res1) {
      break;
    }
    let j = 0;
    while (j < str2.length) {
      let res2;
      [j, res2] = _cut(str2, substr2, j);
      if (!res2) {
        break;
      }
      if (res1.head === res2.head && res1.tail === res2.tail) {
        return res1;
      }
    }
  }
  return null;
}
function _cut(str, substr, from) {
  let start = str.indexOf(substr, from);
  if (start >= 0) {
    let end = start + substr.length;
    return [end, {
      head: str.substr(0, start),
      tail: str.substr(end)
    }];
  }
  return [-1, null];
}

// node_modules/@event-calendar/core/src/lib/debounce.js
function debounce(fn, handle, queueStore) {
  queueStore.update((queue) => queue.set(handle, fn));
}
function flushDebounce(queue) {
  run_all(queue);
  queue.clear();
}

// node_modules/@event-calendar/core/src/lib/dom.js
function createElement(tag, className, html, text2) {
  let el = document.createElement(tag);
  el.className = className;
  if (html) {
    el.innerHTML = html;
  } else if (text2) {
    el.innerText = text2;
  }
  return el;
}
function hasYScroll(el) {
  return el.scrollHeight > el.clientHeight;
}
function rect(el) {
  return el.getBoundingClientRect();
}
function ancestor(el, up) {
  while (up--) {
    el = el.parentElement;
  }
  return el;
}
function height(el) {
  return rect(el).height;
}
var payloadProp = symbol();
function setPayload(el, payload) {
  el[payloadProp] = payload;
}
function hasPayload(el) {
  return !!(el == null ? void 0 : el[payloadProp]);
}
function getPayload(el) {
  return el[payloadProp];
}
function getElementWithPayload(x, y, root = document) {
  for (let el of root.elementsFromPoint(x, y)) {
    if (hasPayload(el)) {
      return el;
    }
    if (el.shadowRoot) {
      let shadowEl = getElementWithPayload(x, y, el.shadowRoot);
      if (shadowEl) {
        return shadowEl;
      }
    }
  }
  return null;
}

// node_modules/@event-calendar/core/src/lib/view.js
function createView(view2, _viewTitle, _currentRange, _activeRange) {
  return {
    type: view2,
    title: _viewTitle,
    currentStart: _currentRange.start,
    currentEnd: _currentRange.end,
    activeStart: _activeRange.start,
    activeEnd: _activeRange.end,
    calendar: void 0
  };
}
function toViewWithLocalDates(view2) {
  view2 = assign({}, view2);
  view2.currentStart = toLocalDate(view2.currentStart);
  view2.currentEnd = toLocalDate(view2.currentEnd);
  view2.activeStart = toLocalDate(view2.activeStart);
  view2.activeEnd = toLocalDate(view2.activeEnd);
  return view2;
}

// node_modules/@event-calendar/core/src/lib/events.js
var eventId = 1;
function createEvents(input) {
  return input.map((event) => ({
    id: "id" in event ? String(event.id) : `{generated-${eventId++}}`,
    resourceIds: Array.isArray(event.resourceIds) ? event.resourceIds.map(String) : "resourceId" in event ? [String(event.resourceId)] : [],
    allDay: event.allDay ?? (noTimePart(event.start) && noTimePart(event.end)),
    start: createDate(event.start),
    end: createDate(event.end),
    title: event.title || "",
    titleHTML: event.titleHTML || "",
    editable: event.editable,
    startEditable: event.startEditable,
    durationEditable: event.durationEditable,
    display: event.display || "auto",
    extendedProps: event.extendedProps || {},
    backgroundColor: event.backgroundColor || event.color,
    textColor: event.textColor
  }));
}
function createEventSources(input) {
  return input.map((source) => ({
    events: source.events,
    url: source.url && source.url.trimEnd("&") || "",
    method: source.method && source.method.toUpperCase() || "GET",
    extraParams: source.extraParams || {}
  }));
}
function createEventChunk(event, start, end) {
  return {
    start: event.start > start ? event.start : start,
    end: event.end < end ? event.end : end,
    event
  };
}
function sortEventChunks(chunks) {
  chunks.sort((a, b) => a.start - b.start || b.event.allDay - a.event.allDay);
}
function prepareEventChunks(chunks, hiddenDays) {
  let longChunks = {};
  if (chunks.length) {
    sortEventChunks(chunks);
    let prevChunk;
    for (let chunk of chunks) {
      let dates = [];
      let date = setMidnight(cloneDate(chunk.start));
      while (chunk.end > date) {
        if (!hiddenDays.includes(date.getUTCDay())) {
          dates.push(cloneDate(date));
          if (dates.length > 1) {
            let key = date.getTime();
            if (longChunks[key]) {
              longChunks[key].chunks.push(chunk);
            } else {
              longChunks[key] = {
                sorted: false,
                chunks: [chunk]
              };
            }
          }
        }
        addDay(date);
      }
      if (dates.length) {
        chunk.date = dates[0];
        chunk.days = dates.length;
        chunk.dates = dates;
        if (chunk.start < dates[0]) {
          chunk.start = dates[0];
        }
        if (setMidnight(cloneDate(chunk.end)) > dates[dates.length - 1]) {
          chunk.end = dates[dates.length - 1];
        }
      } else {
        chunk.date = setMidnight(cloneDate(chunk.start));
        chunk.days = 1;
        chunk.dates = [chunk.date];
      }
      if (prevChunk && datesEqual(prevChunk.date, chunk.date)) {
        chunk.prev = prevChunk;
      }
      prevChunk = chunk;
    }
  }
  return longChunks;
}
function repositionEvent(chunk, longChunks, height2) {
  var _a, _b;
  chunk.top = 0;
  if (chunk.prev) {
    chunk.top = chunk.prev.bottom + 1;
  }
  chunk.bottom = chunk.top + height2;
  let margin = 1;
  let key = chunk.date.getTime();
  if (((_a = longChunks[key]) == null ? void 0 : _a.sorted) || ((_b = longChunks[key]) == null ? void 0 : _b.chunks.every((chunk2) => "top" in chunk2))) {
    if (!longChunks[key].sorted) {
      longChunks[key].chunks.sort((a, b) => a.top - b.top);
      longChunks[key].sorted = true;
    }
    for (let longChunk of longChunks[key].chunks) {
      if (chunk.top < longChunk.bottom && chunk.bottom > longChunk.top) {
        let offset = longChunk.bottom - chunk.top + 1;
        margin += offset;
        chunk.top += offset;
        chunk.bottom += offset;
      }
    }
  }
  return margin;
}
function createEventContent(chunk, displayEventEnd, eventContent, theme, _intlEventTime, _view) {
  let timeText = _intlEventTime.format(chunk.start), content;
  if (displayEventEnd && chunk.event.display !== "pointer") {
    timeText += ` - ${_intlEventTime.format(chunk.end)}`;
  }
  if (eventContent) {
    content = is_function(eventContent) ? eventContent({
      event: toEventWithLocalDates(chunk.event),
      timeText,
      view: toViewWithLocalDates(_view)
    }) : eventContent;
  } else {
    switch (chunk.event.display) {
      case "background":
        content = "";
        break;
      case "pointer":
        content = {
          domNodes: [createElement("div", theme.eventTime, null, timeText)]
        };
        break;
      default:
        content = {
          domNodes: [
            ...chunk.event.allDay ? [] : [createElement("div", theme.eventTime, null, timeText)],
            createElement("div", theme.eventTitle, chunk.event.titleHTML, chunk.event.title)
          ]
        };
    }
  }
  return [timeText, content];
}
function createEventClasses(eventClassNames, event, _view) {
  if (eventClassNames) {
    if (is_function(eventClassNames)) {
      eventClassNames = eventClassNames({
        event: toEventWithLocalDates(event),
        view: toViewWithLocalDates(_view)
      });
    }
    return Array.isArray(eventClassNames) ? eventClassNames : [eventClassNames];
  }
  return [];
}
function toEventWithLocalDates(event) {
  return _cloneEvent(event, toLocalDate);
}
function cloneEvent(event) {
  return _cloneEvent(event, cloneDate);
}
function _cloneEvent(event, dateFn) {
  event = assign({}, event);
  event.start = dateFn(event.start);
  event.end = dateFn(event.end);
  return event;
}
function eventIntersects(event, start, end, resource, timeMode) {
  return (event.start < end && event.end > start || !timeMode && datesEqual(event.start, event.end, start)) && (resource === void 0 || event.resourceIds.includes(resource.id));
}
function helperEvent(display) {
  return previewEvent(display) || ghostEvent(display) || pointerEvent(display);
}
function bgEvent(display) {
  return display === "background";
}
function previewEvent(display) {
  return display === "preview";
}
function ghostEvent(display) {
  return display === "ghost";
}
function pointerEvent(display) {
  return display === "pointer";
}

// node_modules/@event-calendar/core/src/lib/stores.js
function writable2(value, parser, start) {
  return {
    ...writable(parser ? parser(value) : value, start),
    parse: parser
  };
}
function derived2(stores, fn, initValue) {
  let storeValue = initValue;
  let hasSubscribers = false;
  let auto = fn.length < 2;
  let fn2 = (_, set) => {
    hasSubscribers = true;
    if (auto) {
      storeValue = fn(_, set);
      set(storeValue);
    } else {
      fn(_, (value) => {
        storeValue = value;
        set(value);
      });
    }
    return () => {
      hasSubscribers = false;
    };
  };
  let store = derived(stores, fn2, storeValue);
  return {
    ...store,
    get: () => hasSubscribers ? storeValue : get_store_value(store)
  };
}
function intl(locale, format) {
  return derived([locale, format], ([$locale, $format]) => {
    let intl2 = is_function($format) ? { format: $format } : new Intl.DateTimeFormat($locale, $format);
    return {
      format: (date) => intl2.format(toLocalDate(date))
    };
  });
}
function intlRange(locale, format) {
  return derived([locale, format], ([$locale, $format]) => {
    if (is_function($format)) {
      return { format: (start, end) => $format(toLocalDate(start), toLocalDate(end)) };
    }
    let intl2 = new Intl.DateTimeFormat($locale, $format);
    return {
      format: (start, end) => formatRange(toLocalDate(start), toLocalDate(end), intl2)
    };
  });
}

// node_modules/@event-calendar/core/src/storage/options.js
function createOptions(plugins) {
  var _a;
  let options = {
    allDayContent: void 0,
    allDaySlot: true,
    buttonText: {
      today: "today"
    },
    date: /* @__PURE__ */ new Date(),
    datesSet: void 0,
    dayHeaderFormat: {
      weekday: "short",
      month: "numeric",
      day: "numeric"
    },
    displayEventEnd: true,
    duration: { weeks: 1 },
    events: [],
    eventBackgroundColor: void 0,
    eventTextColor: void 0,
    eventClassNames: void 0,
    eventClick: void 0,
    eventColor: void 0,
    eventContent: void 0,
    eventDidMount: void 0,
    eventMouseEnter: void 0,
    eventMouseLeave: void 0,
    eventSources: [],
    eventTimeFormat: {
      hour: "numeric",
      minute: "2-digit"
    },
    firstDay: 0,
    flexibleSlotTimeLimits: false,
    // ec option
    headerToolbar: {
      start: "title",
      center: "",
      end: "today prev,next"
    },
    height: "auto",
    hiddenDays: [],
    highlightedDates: [],
    // ec option
    lazyFetching: true,
    loading: void 0,
    locale: void 0,
    nowIndicator: false,
    selectable: false,
    scrollTime: "06:00:00",
    slotDuration: "00:30:00",
    slotEventOverlap: true,
    slotHeight: 24,
    // ec option
    slotLabelFormat: {
      hour: "numeric",
      minute: "2-digit"
    },
    slotMaxTime: "24:00:00",
    slotMinTime: "00:00:00",
    theme: {
      allDay: "ec-all-day",
      active: "ec-active",
      bgEvent: "ec-bg-event",
      bgEvents: "ec-bg-events",
      body: "ec-body",
      button: "ec-button",
      buttonGroup: "ec-button-group",
      calendar: "ec",
      compact: "ec-compact",
      content: "ec-content",
      day: "ec-day",
      dayHead: "ec-day-head",
      days: "ec-days",
      event: "ec-event",
      eventBody: "ec-event-body",
      eventTime: "ec-event-time",
      eventTitle: "ec-event-title",
      events: "ec-events",
      extra: "ec-extra",
      handle: "ec-handle",
      header: "ec-header",
      hiddenScroll: "ec-hidden-scroll",
      highlight: "ec-highlight",
      icon: "ec-icon",
      line: "ec-line",
      lines: "ec-lines",
      nowIndicator: "ec-now-indicator",
      otherMonth: "ec-other-month",
      sidebar: "ec-sidebar",
      sidebarTitle: "ec-sidebar-title",
      today: "ec-today",
      time: "ec-time",
      title: "ec-title",
      toolbar: "ec-toolbar",
      week: "ec-week",
      withScroll: "ec-with-scroll"
    },
    titleFormat: {
      year: "numeric",
      month: "short",
      day: "numeric"
    },
    view: void 0,
    viewDidMount: void 0,
    views: {}
  };
  for (let plugin of plugins) {
    (_a = plugin.createOptions) == null ? void 0 : _a.call(plugin, options);
  }
  return options;
}
function createParsers(options, plugins) {
  var _a;
  let parsers = {
    buttonText: (input) => is_function(input) ? input(options.buttonText) : input,
    date: (date) => setMidnight(createDate(date)),
    duration: createDuration,
    events: createEvents,
    eventSources: createEventSources,
    hiddenDays: (days) => [...new Set(days)],
    highlightedDates: (dates) => dates.map(createDate),
    scrollTime: createDuration,
    slotDuration: createDuration,
    slotMaxTime: createDuration,
    slotMinTime: createDuration,
    theme: (input) => is_function(input) ? input(options.theme) : input
  };
  for (let plugin of plugins) {
    (_a = plugin.createParsers) == null ? void 0 : _a.call(plugin, parsers, options);
  }
  return parsers;
}
var prev;
function diff(options) {
  let diff2 = [];
  if (prev) {
    for (let name of Object.keys(options)) {
      if (options[name] !== prev[name]) {
        diff2.push([name, options[name]]);
      }
    }
  }
  prev = assign({}, options);
  return diff2;
}

// node_modules/@event-calendar/core/src/storage/stores.js
function monthMode(state) {
  return derived(state.view, ($view) => {
    var _a;
    return (_a = $view.startsWith) == null ? void 0 : _a.call($view, "dayGrid");
  });
}
function activeRange(state) {
  return derived(
    [state._currentRange, state.firstDay, state.slotMaxTime, state._monthMode],
    ([$_currentRange, $firstDay, $slotMaxTime, $_monthMode]) => {
      let start = cloneDate($_currentRange.start);
      let end = cloneDate($_currentRange.end);
      if ($_monthMode) {
        prevClosestDay(start, $firstDay);
        nextClosestDay(end, $firstDay);
      } else if ($slotMaxTime.days || $slotMaxTime.seconds > DAY_IN_SECONDS) {
        addDuration(subtractDay(end), $slotMaxTime);
        let start2 = subtractDay(cloneDate(end));
        if (start2 < start) {
          start = start2;
        }
      }
      return { start, end };
    }
  );
}
function currentRange(state) {
  return derived(
    [state.date, state.duration, state.firstDay, state._monthMode],
    ([$date, $duration, $firstDay, $_monthMode]) => {
      let start = cloneDate($date), end;
      if ($_monthMode) {
        start.setUTCDate(1);
      } else if ($duration.inWeeks) {
        prevClosestDay(start, $firstDay);
      }
      end = addDuration(cloneDate(start), $duration);
      return { start, end };
    }
  );
}
function viewDates(state) {
  return derived2([state._activeRange, state.hiddenDays], ([$_activeRange, $hiddenDays]) => {
    let dates = [];
    let date = setMidnight(cloneDate($_activeRange.start));
    let end = setMidnight(cloneDate($_activeRange.end));
    while (date < end) {
      if (!$hiddenDays.includes(date.getUTCDay())) {
        dates.push(cloneDate(date));
      }
      addDay(date);
    }
    if (!dates.length && $hiddenDays.length && $hiddenDays.length < 7) {
      state.date.update((date2) => {
        while ($hiddenDays.includes(date2.getUTCDay())) {
          addDay(date2);
        }
        return date2;
      });
      dates = state._viewDates.get();
    }
    return dates;
  });
}
function viewTitle(state) {
  return derived(
    [state.date, state._activeRange, state._titleIntlRange, state._monthMode],
    ([$date, $_activeRange, $_titleIntlRange, $_monthMode]) => {
      return $_monthMode ? $_titleIntlRange.format($date, $date) : $_titleIntlRange.format($_activeRange.start, subtractDay(cloneDate($_activeRange.end)));
    }
  );
}
function view(state) {
  return derived2([state.view, state._viewTitle, state._currentRange, state._activeRange], (args) => createView(...args));
}
function events(state) {
  let _events = writable([]);
  let abortController;
  let fetching = 0;
  let debounceHandle = {};
  derived(
    [state.events, state.eventSources, state._activeRange, state._fetchedRange, state.lazyFetching, state.loading],
    (values, set) => debounce(() => {
      let [$events, $eventSources, $_activeRange, $_fetchedRange, $lazyFetching, $loading] = values;
      if (!$eventSources.length) {
        set($events);
        return;
      }
      if (!$_fetchedRange.start || $_fetchedRange.start > $_activeRange.start || $_fetchedRange.end < $_activeRange.end || !$lazyFetching) {
        if (abortController) {
          abortController.abort();
        }
        abortController = new AbortController();
        if (is_function($loading) && !fetching) {
          $loading(true);
        }
        let stopLoading = () => {
          if (--fetching === 0 && is_function($loading)) {
            $loading(false);
          }
        };
        let events2 = [];
        let failure = (e) => stopLoading();
        let success = (data) => {
          events2 = events2.concat(createEvents(data));
          set(events2);
          stopLoading();
        };
        let startStr = toISOString($_activeRange.start);
        let endStr = toISOString($_activeRange.end);
        for (let source of $eventSources) {
          if (is_function(source.events)) {
            let result = source.events({
              start: toLocalDate($_activeRange.start),
              end: toLocalDate($_activeRange.end),
              startStr,
              endStr
            }, success, failure);
            if (result !== void 0) {
              Promise.resolve(result).then(success, failure);
            }
          } else {
            let params = is_function(source.extraParams) ? source.extraParams() : assign({}, source.extraParams);
            params.start = startStr;
            params.end = endStr;
            params = new URLSearchParams(params);
            let url = source.url, headers = {}, body;
            if (["GET", "HEAD"].includes(source.method)) {
              url += (url.includes("?") ? "&" : "?") + params;
            } else {
              headers["content-type"] = "application/x-www-form-urlencoded;charset=UTF-8";
              body = String(params);
            }
            fetch(url, { method: source.method, headers, body, signal: abortController.signal, credentials: "same-origin" }).then((response) => response.json()).then(success).catch(failure);
          }
          ++fetching;
        }
        $_fetchedRange.start = $_activeRange.start;
        $_fetchedRange.end = $_activeRange.end;
      }
    }, debounceHandle, state._queue),
    []
  ).subscribe(_events.set);
  return _events;
}
function now() {
  return readable(createDate(), (set) => {
    let interval = setInterval(() => {
      set(createDate());
    }, 1e3);
    return () => clearInterval(interval);
  });
}
function today(state) {
  return derived(state._now, ($_now) => setMidnight(cloneDate($_now)));
}

// node_modules/@event-calendar/core/src/storage/state.js
var state_default = class {
  constructor(plugins, input) {
    var _a;
    plugins = plugins || [];
    let options = createOptions(plugins);
    let parsers = createParsers(options, plugins);
    for (let [option, value] of Object.entries(options)) {
      this[option] = writable2(value, parsers[option]);
    }
    this._queue = writable(/* @__PURE__ */ new Map());
    this._auxiliary = writable([]);
    this._monthMode = monthMode(this);
    this._currentRange = currentRange(this);
    this._activeRange = activeRange(this);
    this._fetchedRange = writable({ start: void 0, end: void 0 });
    this._events = events(this);
    this._now = now();
    this._today = today(this);
    this._intlEventTime = intl(this.locale, this.eventTimeFormat);
    this._intlSlotLabel = intl(this.locale, this.slotLabelFormat);
    this._intlDayHeader = intl(this.locale, this.dayHeaderFormat);
    this._titleIntlRange = intlRange(this.locale, this.titleFormat);
    this._bodyEl = writable(void 0);
    this._scrollable = writable(false);
    this._viewTitle = viewTitle(this);
    this._viewDates = viewDates(this);
    this._view = view(this);
    this._viewClass = writable(void 0);
    this._viewComponent = writable(void 0);
    this._resBgColor = writable(noop);
    this._resTxtColor = writable(noop);
    this._interaction = writable({});
    this._iEvents = writable([null, null]);
    this._iClasses = writable(identity);
    this._iClass = writable(void 0);
    for (let plugin of plugins) {
      (_a = plugin.createStores) == null ? void 0 : _a.call(plugin, this);
    }
    if (input.view) {
      this.view.set(input.view);
    }
    let commonOpts = assign({}, options, input);
    parseOpts(commonOpts, this);
    let views = /* @__PURE__ */ new Set([...Object.keys(options.views), ...Object.keys(input.views || {})]);
    for (let view2 of views) {
      let viewOpts = assign({}, options.views[view2] || {}, input.views && input.views[view2] || {});
      parseOpts(viewOpts, this);
      let opts = assign({}, commonOpts, viewOpts);
      this.view.subscribe((newView) => {
        if (newView === view2) {
          this._viewComponent.set(opts.component);
          if (is_function(opts.viewDidMount)) {
            tick().then(() => opts.viewDidMount(this._view.get()));
          }
        }
      });
      for (let key of Object.keys(opts)) {
        if (this.hasOwnProperty(key) && key[0] !== "_") {
          let { set, _set, ...rest } = this[key];
          if (!_set) {
            _set = set;
          }
          this[key] = {
            // Set value in all views
            set: (value) => {
              opts[key] = value;
              set(value);
            },
            _set,
            ...rest
          };
          this.view.subscribe((newView) => {
            if (newView === view2) {
              _set(opts[key]);
            }
          });
        }
      }
    }
  }
};
function parseOpts(opts, state) {
  for (let key of Object.keys(opts)) {
    if (state.hasOwnProperty(key) && key[0] !== "_") {
      if (state[key].parse) {
        opts[key] = state[key].parse(opts[key]);
      }
    }
  }
}

// node_modules/@event-calendar/core/src/Buttons.svelte
var file = "node_modules\\@event-calendar\\core\\src\\Buttons.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let button;
  let t_value = (
    /*$buttonText*/
    ctx[5][
      /*button*/
      ctx[23]
    ] + ""
  );
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[20](
        /*button*/
        ctx[23]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = /*$theme*/
      ctx[3].button + /*$view*/
      (ctx[6] === /*button*/
      ctx[23] ? " " + /*$theme*/
      ctx[3].active : "") + " ec-" + /*button*/
      ctx[23]);
      add_location(button, file, 38, 8, 1433);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler_1, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$buttonText, buttons*/
      33 && t_value !== (t_value = /*$buttonText*/
      ctx[5][
        /*button*/
        ctx[23]
      ] + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$theme, $view, buttons*/
      73 && button_class_value !== (button_class_value = /*$theme*/
      ctx[3].button + /*$view*/
      (ctx[6] === /*button*/
      ctx[23] ? " " + /*$theme*/
      ctx[3].active : "") + " ec-" + /*button*/
      ctx[23])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(38:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let button;
  let t_value = (
    /*$buttonText*/
    ctx[5][
      /*button*/
      ctx[23]
    ] + ""
  );
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[23]);
      button.disabled = /*isToday*/
      ctx[1];
      add_location(button, file, 36, 8, 1277);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[19],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$buttonText, buttons*/
      33 && t_value !== (t_value = /*$buttonText*/
      ctx2[5][
        /*button*/
        ctx2[23]
      ] + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$theme, buttons*/
      9 && button_class_value !== (button_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[23])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty & /*isToday*/
      2) {
        prop_dev(
          button,
          "disabled",
          /*isToday*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(36:33) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let button;
  let i;
  let i_class_value;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      i = claim_element(button_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = /*$theme*/
      ctx[3].icon + " ec-" + /*button*/
      ctx[23]);
      add_location(i, file, 34, 68, 1184);
      attr_dev(button, "class", button_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[23]);
      add_location(button, file, 34, 8, 1124);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, i);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*next*/
          ctx[17],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, buttons*/
      9 && i_class_value !== (i_class_value = /*$theme*/
      ctx2[3].icon + " ec-" + /*button*/
      ctx2[23])) {
        attr_dev(i, "class", i_class_value);
      }
      if (dirty & /*$theme, buttons*/
      9 && button_class_value !== (button_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[23])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(34:32) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let button;
  let i;
  let i_class_value;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      i = claim_element(button_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = /*$theme*/
      ctx[3].icon + " ec-" + /*button*/
      ctx[23]);
      add_location(i, file, 32, 68, 1032);
      attr_dev(button, "class", button_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[23]);
      add_location(button, file, 32, 8, 972);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, i);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*prev*/
          ctx[16],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, buttons*/
      9 && i_class_value !== (i_class_value = /*$theme*/
      ctx2[3].icon + " ec-" + /*button*/
      ctx2[23])) {
        attr_dev(i, "class", i_class_value);
      }
      if (dirty & /*$theme, buttons*/
      9 && button_class_value !== (button_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[23])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(32:31) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let h2;
  let t;
  let h2_class_value;
  const block = {
    c: function create() {
      h2 = element("h2");
      t = text(
        /*$_viewTitle*/
        ctx[4]
      );
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", { class: true });
      var h2_nodes = children(h2);
      t = claim_text(
        h2_nodes,
        /*$_viewTitle*/
        ctx[4]
      );
      h2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h2, "class", h2_class_value = /*$theme*/
      ctx[3].title);
      add_location(h2, file, 30, 8, 886);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      append_hydration_dev(h2, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$_viewTitle*/
      16)
        set_data_dev(
          t,
          /*$_viewTitle*/
          ctx2[4]
        );
      if (dirty & /*$theme*/
      8 && h2_class_value !== (h2_class_value = /*$theme*/
      ctx2[3].title)) {
        attr_dev(h2, "class", h2_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(30:32) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(29:4) {#if button == ''}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*button*/
      ctx2[23] == ""
    )
      return create_if_block;
    if (
      /*button*/
      ctx2[23] == "title"
    )
      return create_if_block_1;
    if (
      /*button*/
      ctx2[23] == "prev"
    )
      return create_if_block_2;
    if (
      /*button*/
      ctx2[23] === "next"
    )
      return create_if_block_3;
    if (
      /*button*/
      ctx2[23] === "today"
    )
      return create_if_block_4;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(28:0) {#each buttons as button}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let each_1_anchor;
  let each_value = (
    /*buttons*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*buttons, $theme, $_viewTitle, prev, next, isToday, $date, cloneDate, today, $buttonText, $view*/
      229503) {
        each_value = /*buttons*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $duration;
  let $date;
  let $hiddenDays;
  let $_currentRange;
  let $theme;
  let $_viewTitle;
  let $buttonText;
  let $view;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Buttons", slots, []);
  let { buttons } = $$props;
  let { _currentRange, _viewTitle, buttonText, date, duration, hiddenDays, theme, view: view2 } = getContext("state");
  validate_store(_currentRange, "_currentRange");
  component_subscribe($$self, _currentRange, (value) => $$invalidate(18, $_currentRange = value));
  validate_store(_viewTitle, "_viewTitle");
  component_subscribe($$self, _viewTitle, (value) => $$invalidate(4, $_viewTitle = value));
  validate_store(buttonText, "buttonText");
  component_subscribe($$self, buttonText, (value) => $$invalidate(5, $buttonText = value));
  validate_store(date, "date");
  component_subscribe($$self, date, (value) => $$invalidate(2, $date = value));
  validate_store(duration, "duration");
  component_subscribe($$self, duration, (value) => $$invalidate(21, $duration = value));
  validate_store(hiddenDays, "hiddenDays");
  component_subscribe($$self, hiddenDays, (value) => $$invalidate(22, $hiddenDays = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(3, $theme = value));
  validate_store(view2, "view");
  component_subscribe($$self, view2, (value) => $$invalidate(6, $view = value));
  let today2 = setMidnight(createDate()), isToday;
  function prev2() {
    let d = subtractDuration($date, $duration);
    if ($hiddenDays.length && $hiddenDays.length < 7) {
      while ($hiddenDays.includes(d.getUTCDay())) {
        subtractDay(d);
      }
    }
    set_store_value(date, $date = d, $date);
  }
  function next() {
    set_store_value(date, $date = addDuration($date, $duration), $date);
  }
  $$self.$$.on_mount.push(function() {
    if (buttons === void 0 && !("buttons" in $$props || $$self.$$.bound[$$self.$$.props["buttons"]])) {
      console.warn("<Buttons> was created without expected prop 'buttons'");
    }
  });
  const writable_props = ["buttons"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Buttons> was created with unknown prop '${key}'`);
  });
  const click_handler = () => set_store_value(date, $date = cloneDate(today2), $date);
  const click_handler_1 = (button) => set_store_value(view2, $view = button, $view);
  $$self.$$set = ($$props2) => {
    if ("buttons" in $$props2)
      $$invalidate(0, buttons = $$props2.buttons);
  };
  $$self.$capture_state = () => ({
    getContext,
    createDate,
    cloneDate,
    subtractDay,
    addDuration,
    subtractDuration,
    setMidnight,
    buttons,
    _currentRange,
    _viewTitle,
    buttonText,
    date,
    duration,
    hiddenDays,
    theme,
    view: view2,
    today: today2,
    isToday,
    prev: prev2,
    next,
    $duration,
    $date,
    $hiddenDays,
    $_currentRange,
    $theme,
    $_viewTitle,
    $buttonText,
    $view
  });
  $$self.$inject_state = ($$props2) => {
    if ("buttons" in $$props2)
      $$invalidate(0, buttons = $$props2.buttons);
    if ("_currentRange" in $$props2)
      $$invalidate(7, _currentRange = $$props2._currentRange);
    if ("_viewTitle" in $$props2)
      $$invalidate(8, _viewTitle = $$props2._viewTitle);
    if ("buttonText" in $$props2)
      $$invalidate(9, buttonText = $$props2.buttonText);
    if ("date" in $$props2)
      $$invalidate(10, date = $$props2.date);
    if ("duration" in $$props2)
      $$invalidate(11, duration = $$props2.duration);
    if ("hiddenDays" in $$props2)
      $$invalidate(12, hiddenDays = $$props2.hiddenDays);
    if ("theme" in $$props2)
      $$invalidate(13, theme = $$props2.theme);
    if ("view" in $$props2)
      $$invalidate(14, view2 = $$props2.view);
    if ("today" in $$props2)
      $$invalidate(15, today2 = $$props2.today);
    if ("isToday" in $$props2)
      $$invalidate(1, isToday = $$props2.isToday);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_currentRange*/
    262144) {
      $:
        $$invalidate(1, isToday = today2 >= $_currentRange.start && today2 < $_currentRange.end || null);
    }
  };
  return [
    buttons,
    isToday,
    $date,
    $theme,
    $_viewTitle,
    $buttonText,
    $view,
    _currentRange,
    _viewTitle,
    buttonText,
    date,
    duration,
    hiddenDays,
    theme,
    view2,
    today2,
    prev2,
    next,
    $_currentRange,
    click_handler,
    click_handler_1
  ];
}
var Buttons = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { buttons: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Buttons",
      options,
      id: create_fragment.name
    });
  }
  get buttons() {
    throw new Error("<Buttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttons(value) {
    throw new Error("<Buttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Buttons_default = Buttons;

// node_modules/@event-calendar/core/src/Toolbar.svelte
var { Object: Object_1 } = globals;
var file2 = "node_modules\\@event-calendar\\core\\src\\Toolbar.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_else_block2(ctx) {
  let buttons;
  let current;
  buttons = new Buttons_default({
    props: { buttons: (
      /*buttons*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(buttons.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(buttons.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(buttons, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const buttons_changes = {};
      if (dirty & /*sections*/
      1)
        buttons_changes.buttons = /*buttons*/
        ctx2[8];
      buttons.$set(buttons_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(buttons, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(28:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let buttons;
  let div_class_value;
  let current;
  buttons = new Buttons_default({
    props: { buttons: (
      /*buttons*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(buttons.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(buttons.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].buttonGroup);
      add_location(div, file2, 24, 20, 600);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(buttons, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const buttons_changes = {};
      if (dirty & /*sections*/
      1)
        buttons_changes.buttons = /*buttons*/
        ctx2[8];
      buttons.$set(buttons_changes);
      if (!current || dirty & /*$theme*/
      2 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].buttonGroup)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(buttons);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(24:16) {#if buttons.length > 1}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*buttons*/
      ctx2[8].length > 1
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(23:12) {#each sections[key] as buttons}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let div;
  let t;
  let current;
  let each_value_1 = (
    /*sections*/
    ctx[0][
      /*key*/
      ctx[5]
    ]
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file2, 21, 8, 488);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, sections, Object*/
      3) {
        each_value_1 = /*sections*/
        ctx2[0][
          /*key*/
          ctx2[5]
        ];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(21:4) {#each Object.keys(sections) as key}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let div_class_value;
  let current;
  let each_value = Object.keys(
    /*sections*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].toolbar);
      add_location(div, file2, 19, 0, 408);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*sections, Object, $theme*/
      3) {
        each_value = Object.keys(
          /*sections*/
          ctx2[0]
        );
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*$theme*/
      2 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].toolbar)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let $headerToolbar;
  let $theme;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toolbar", slots, []);
  let { headerToolbar, theme } = getContext("state");
  validate_store(headerToolbar, "headerToolbar");
  component_subscribe($$self, headerToolbar, (value) => $$invalidate(4, $headerToolbar = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  let sections = { start: [], center: [], end: [] };
  const writable_props = [];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Toolbar> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    getContext,
    Buttons: Buttons_default,
    headerToolbar,
    theme,
    sections,
    $headerToolbar,
    $theme
  });
  $$self.$inject_state = ($$props2) => {
    if ("headerToolbar" in $$props2)
      $$invalidate(2, headerToolbar = $$props2.headerToolbar);
    if ("theme" in $$props2)
      $$invalidate(3, theme = $$props2.theme);
    if ("sections" in $$props2)
      $$invalidate(0, sections = $$props2.sections);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sections, $headerToolbar*/
    17) {
      $: {
        for (let key of Object.keys(sections)) {
          $$invalidate(0, sections[key] = $headerToolbar[key].split(" ").map((group) => group.split(",")), sections);
        }
      }
    }
  };
  return [sections, $theme, headerToolbar, theme, $headerToolbar];
}
var Toolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toolbar",
      options,
      id: create_fragment2.name
    });
  }
};
var Toolbar_default = Toolbar;

// node_modules/@event-calendar/core/src/Auxiliary.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_each_block3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*component*/
    ctx[11]
  );
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$_auxiliary*/
      1 && switch_value !== (switch_value = /*component*/
      ctx2[11])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(25:0) {#each $_auxiliary as component}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*$_auxiliary*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$_auxiliary*/
      1) {
        each_value = /*$_auxiliary*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $_view;
  let $datesSet;
  let $_activeRange;
  let $_auxiliary;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Auxiliary", slots, []);
  let { datesSet, _auxiliary, _activeRange, _queue, _view } = getContext("state");
  validate_store(datesSet, "datesSet");
  component_subscribe($$self, datesSet, (value) => $$invalidate(7, $datesSet = value));
  validate_store(_auxiliary, "_auxiliary");
  component_subscribe($$self, _auxiliary, (value) => $$invalidate(0, $_auxiliary = value));
  validate_store(_activeRange, "_activeRange");
  component_subscribe($$self, _activeRange, (value) => $$invalidate(5, $_activeRange = value));
  validate_store(_view, "_view");
  component_subscribe($$self, _view, (value) => $$invalidate(6, $_view = value));
  let debounceHandle = {};
  function runDatesSet(_activeRange2) {
    if (is_function($datesSet)) {
      debounce(
        () => $datesSet({
          start: toLocalDate(_activeRange2.start),
          end: toLocalDate(_activeRange2.end),
          startStr: toISOString(_activeRange2.start),
          endStr: toISOString(_activeRange2.end),
          view: toViewWithLocalDates($_view)
        }),
        debounceHandle,
        _queue
      );
    }
  }
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Auxiliary> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    getContext,
    is_function,
    debounce,
    toISOString,
    toLocalDate,
    toViewWithLocalDates,
    datesSet,
    _auxiliary,
    _activeRange,
    _queue,
    _view,
    debounceHandle,
    runDatesSet,
    $_view,
    $datesSet,
    $_activeRange,
    $_auxiliary
  });
  $$self.$inject_state = ($$props2) => {
    if ("datesSet" in $$props2)
      $$invalidate(1, datesSet = $$props2.datesSet);
    if ("_auxiliary" in $$props2)
      $$invalidate(2, _auxiliary = $$props2._auxiliary);
    if ("_activeRange" in $$props2)
      $$invalidate(3, _activeRange = $$props2._activeRange);
    if ("_queue" in $$props2)
      _queue = $$props2._queue;
    if ("_view" in $$props2)
      $$invalidate(4, _view = $$props2._view);
    if ("debounceHandle" in $$props2)
      debounceHandle = $$props2.debounceHandle;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_activeRange*/
    32) {
      $:
        runDatesSet($_activeRange);
    }
  };
  return [$_auxiliary, datesSet, _auxiliary, _activeRange, _view, $_activeRange];
}
var Auxiliary = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Auxiliary",
      options,
      id: create_fragment3.name
    });
  }
};
var Auxiliary_default = Auxiliary;

// node_modules/@event-calendar/core/src/Calendar.svelte
var file3 = "node_modules\\@event-calendar\\core\\src\\Calendar.svelte";
function create_fragment4(ctx) {
  let div;
  let toolbar;
  let t0;
  let switch_instance;
  let div_class_value;
  let t1;
  let auxiliary;
  let current;
  let mounted;
  let dispose;
  toolbar = new Toolbar_default({ $$inline: true });
  var switch_value = (
    /*$_viewComponent*/
    ctx[5]
  );
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  auxiliary = new Auxiliary_default({ $$inline: true });
  const block = {
    c: function create() {
      div = element("div");
      create_component(toolbar.$$.fragment);
      t0 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t1 = space();
      create_component(auxiliary.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      claim_component(toolbar.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      claim_component(auxiliary.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].calendar + /*$_viewClass*/
      (ctx[2] ? " " + /*$theme*/
      ctx[1][
        /*$_viewClass*/
        ctx[2]
      ] : "") + /*$_scrollable*/
      (ctx[0] ? " " + /*$theme*/
      ctx[1].withScroll : "") + /*$_iClass*/
      (ctx[3] ? " " + /*$theme*/
      ctx[1][
        /*$_iClass*/
        ctx[3]
      ] : ""));
      set_style(
        div,
        "height",
        /*$height*/
        ctx[4]
      );
      add_location(div, file3, 131, 0, 3480);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(toolbar, div, null);
      append_hydration_dev(div, t0);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      insert_hydration_dev(target, t1, anchor);
      mount_component(auxiliary, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "resize",
          /*recheckScrollable*/
          ctx[18],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$_viewComponent*/
      32 && switch_value !== (switch_value = /*$_viewComponent*/
      ctx2[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (!current || dirty[0] & /*$theme, $_viewClass, $_scrollable, $_iClass*/
      15 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].calendar + /*$_viewClass*/
      (ctx2[2] ? " " + /*$theme*/
      ctx2[1][
        /*$_viewClass*/
        ctx2[2]
      ] : "") + /*$_scrollable*/
      (ctx2[0] ? " " + /*$theme*/
      ctx2[1].withScroll : "") + /*$_iClass*/
      (ctx2[3] ? " " + /*$theme*/
      ctx2[1][
        /*$_iClass*/
        ctx2[3]
      ] : ""))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*$height*/
      16) {
        set_style(
          div,
          "height",
          /*$height*/
          ctx2[4]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(auxiliary.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toolbar.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(auxiliary.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(toolbar);
      if (switch_instance)
        destroy_component(switch_instance);
      if (detaching)
        detach_dev(t1);
      destroy_component(auxiliary, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $_bodyEl;
  let $_scrollable;
  let $_queue;
  let $_events;
  let $events;
  let $eventSources;
  let $_interaction;
  let $theme;
  let $_viewClass;
  let $_iClass;
  let $height;
  let $_viewComponent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Calendar", slots, []);
  let { plugins = [] } = $$props;
  let { options = {} } = $$props;
  let component = get_current_component();
  let state = new state_default(plugins, options);
  setContext("state", state);
  let { _viewComponent, _viewClass, _bodyEl, _interaction, _iClass, _events, _queue, _scrollable, events: events2, eventSources, height: height2, theme } = state;
  validate_store(_viewComponent, "_viewComponent");
  component_subscribe($$self, _viewComponent, (value) => $$invalidate(5, $_viewComponent = value));
  validate_store(_viewClass, "_viewClass");
  component_subscribe($$self, _viewClass, (value) => $$invalidate(2, $_viewClass = value));
  validate_store(_bodyEl, "_bodyEl");
  component_subscribe($$self, _bodyEl, (value) => $$invalidate(33, $_bodyEl = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(38, $_interaction = value));
  validate_store(_iClass, "_iClass");
  component_subscribe($$self, _iClass, (value) => $$invalidate(3, $_iClass = value));
  validate_store(_events, "_events");
  component_subscribe($$self, _events, (value) => $$invalidate(35, $_events = value));
  validate_store(_queue, "_queue");
  component_subscribe($$self, _queue, (value) => $$invalidate(34, $_queue = value));
  validate_store(_scrollable, "_scrollable");
  component_subscribe($$self, _scrollable, (value) => $$invalidate(0, $_scrollable = value));
  validate_store(events2, "events");
  component_subscribe($$self, events2, (value) => $$invalidate(36, $events = value));
  validate_store(eventSources, "eventSources");
  component_subscribe($$self, eventSources, (value) => $$invalidate(37, $eventSources = value));
  validate_store(height2, "height");
  component_subscribe($$self, height2, (value) => $$invalidate(4, $height = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  function setOption(name, value) {
    if (state.hasOwnProperty(name)) {
      if (state[name].parse) {
        value = state[name].parse(value);
      }
      state[name].set(value);
    }
    return this;
  }
  function getOption(name) {
    let value = state.hasOwnProperty(name) ? get_store_value(state[name]) : void 0;
    return value instanceof Date ? toLocalDate(value) : value;
  }
  function refetchEvents() {
    state._fetchedRange.set({ start: void 0, end: void 0 });
    return this;
  }
  function getEvents() {
    return $_events.map(toEventWithLocalDates);
  }
  function getEventById(id) {
    for (let event of $_events) {
      if (event.id == id) {
        return toEventWithLocalDates(event);
      }
    }
    return null;
  }
  function addEvent(event) {
    updateEvents((events3) => events3.concat(state.events.parse([event])));
    return this;
  }
  function updateEvent(event) {
    updateEvents((events3) => {
      for (let e of events3) {
        if (e.id == event.id) {
          assign(e, state.events.parse([event])[0]);
          break;
        }
      }
      return events3;
    });
    return this;
  }
  function removeEventById(id) {
    updateEvents((events3) => events3.filter((event) => event.id != id));
    return this;
  }
  function getView() {
    return toViewWithLocalDates(state._view.get());
  }
  function unselect() {
    if ($_interaction.action) {
      $_interaction.action.unselect();
    }
    return this;
  }
  function dateFromPoint(x, y) {
    let dayEl = getElementWithPayload(x, y);
    return dayEl ? getPayload(dayEl)(y) : null;
  }
  function destroy() {
    destroy_component(component, true);
  }
  function updateEvents(func) {
    set_store_value(_events, $_events = func($_events), $_events);
    if (!$eventSources.length) {
      set_store_value(events2, $events = $_events, $events);
    }
  }
  beforeUpdate(() => {
    flushDebounce($_queue);
    setTimeout(recheckScrollable);
  });
  function recheckScrollable() {
    if ($_bodyEl) {
      set_store_value(_scrollable, $_scrollable = hasYScroll($_bodyEl), $_scrollable);
    }
  }
  const writable_props = ["plugins", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Calendar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("plugins" in $$props2)
      $$invalidate(19, plugins = $$props2.plugins);
    if ("options" in $$props2)
      $$invalidate(20, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    setContext,
    beforeUpdate,
    destroy_component,
    get_current_component,
    get: get_store_value,
    diff,
    State: state_default,
    Toolbar: Toolbar_default,
    Auxiliary: Auxiliary_default,
    assign,
    toEventWithLocalDates,
    toViewWithLocalDates,
    toLocalDate,
    getElementWithPayload,
    getPayload,
    flushDebounce,
    hasYScroll,
    plugins,
    options,
    component,
    state,
    _viewComponent,
    _viewClass,
    _bodyEl,
    _interaction,
    _iClass,
    _events,
    _queue,
    _scrollable,
    events: events2,
    eventSources,
    height: height2,
    theme,
    setOption,
    getOption,
    refetchEvents,
    getEvents,
    getEventById,
    addEvent,
    updateEvent,
    removeEventById,
    getView,
    unselect,
    dateFromPoint,
    destroy,
    updateEvents,
    recheckScrollable,
    $_bodyEl,
    $_scrollable,
    $_queue,
    $_events,
    $events,
    $eventSources,
    $_interaction,
    $theme,
    $_viewClass,
    $_iClass,
    $height,
    $_viewComponent
  });
  $$self.$inject_state = ($$props2) => {
    if ("plugins" in $$props2)
      $$invalidate(19, plugins = $$props2.plugins);
    if ("options" in $$props2)
      $$invalidate(20, options = $$props2.options);
    if ("component" in $$props2)
      component = $$props2.component;
    if ("state" in $$props2)
      state = $$props2.state;
    if ("_viewComponent" in $$props2)
      $$invalidate(6, _viewComponent = $$props2._viewComponent);
    if ("_viewClass" in $$props2)
      $$invalidate(7, _viewClass = $$props2._viewClass);
    if ("_bodyEl" in $$props2)
      $$invalidate(8, _bodyEl = $$props2._bodyEl);
    if ("_interaction" in $$props2)
      $$invalidate(9, _interaction = $$props2._interaction);
    if ("_iClass" in $$props2)
      $$invalidate(10, _iClass = $$props2._iClass);
    if ("_events" in $$props2)
      $$invalidate(11, _events = $$props2._events);
    if ("_queue" in $$props2)
      $$invalidate(12, _queue = $$props2._queue);
    if ("_scrollable" in $$props2)
      $$invalidate(13, _scrollable = $$props2._scrollable);
    if ("events" in $$props2)
      $$invalidate(14, events2 = $$props2.events);
    if ("eventSources" in $$props2)
      $$invalidate(15, eventSources = $$props2.eventSources);
    if ("height" in $$props2)
      $$invalidate(16, height2 = $$props2.height);
    if ("theme" in $$props2)
      $$invalidate(17, theme = $$props2.theme);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*options*/
    1048576) {
      $:
        for (let [name, value] of diff(options)) {
          setOption(name, value);
        }
    }
  };
  return [
    $_scrollable,
    $theme,
    $_viewClass,
    $_iClass,
    $height,
    $_viewComponent,
    _viewComponent,
    _viewClass,
    _bodyEl,
    _interaction,
    _iClass,
    _events,
    _queue,
    _scrollable,
    events2,
    eventSources,
    height2,
    theme,
    recheckScrollable,
    plugins,
    options,
    setOption,
    getOption,
    refetchEvents,
    getEvents,
    getEventById,
    addEvent,
    updateEvent,
    removeEventById,
    getView,
    unselect,
    dateFromPoint,
    destroy
  ];
}
var Calendar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        plugins: 19,
        options: 20,
        setOption: 21,
        getOption: 22,
        refetchEvents: 23,
        getEvents: 24,
        getEventById: 25,
        addEvent: 26,
        updateEvent: 27,
        removeEventById: 28,
        getView: 29,
        unselect: 30,
        dateFromPoint: 31,
        destroy: 32
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Calendar",
      options,
      id: create_fragment4.name
    });
  }
  get plugins() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plugins(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setOption() {
    return this.$$.ctx[21];
  }
  set setOption(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getOption() {
    return this.$$.ctx[22];
  }
  set getOption(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refetchEvents() {
    return this.$$.ctx[23];
  }
  set refetchEvents(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getEvents() {
    return this.$$.ctx[24];
  }
  set getEvents(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getEventById() {
    return this.$$.ctx[25];
  }
  set getEventById(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addEvent() {
    return this.$$.ctx[26];
  }
  set addEvent(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateEvent() {
    return this.$$.ctx[27];
  }
  set updateEvent(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeEventById() {
    return this.$$.ctx[28];
  }
  set removeEventById(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getView() {
    return this.$$.ctx[29];
  }
  set getView(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unselect() {
    return this.$$.ctx[30];
  }
  set unselect(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dateFromPoint() {
    return this.$$.ctx[31];
  }
  set dateFromPoint(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get destroy() {
    return this.$$.ctx[32];
  }
  set destroy(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Calendar_default = Calendar;

export {
  assign,
  floor,
  min,
  max,
  isObject,
  symbol,
  setContent,
  outsideEvent,
  DAY_IN_SECONDS,
  createDate,
  createDuration,
  cloneDate,
  addDuration,
  subtractDuration,
  addDay,
  subtractDay,
  setMidnight,
  toLocalDate,
  toISOString,
  formatRange,
  datesEqual,
  nextClosestDay,
  prevClosestDay,
  noTimePart,
  debounce,
  flushDebounce,
  createElement,
  hasYScroll,
  rect,
  ancestor,
  height,
  setPayload,
  hasPayload,
  getPayload,
  getElementWithPayload,
  createView,
  toViewWithLocalDates,
  createEvents,
  createEventSources,
  createEventChunk,
  sortEventChunks,
  prepareEventChunks,
  repositionEvent,
  createEventContent,
  createEventClasses,
  toEventWithLocalDates,
  cloneEvent,
  eventIntersects,
  helperEvent,
  bgEvent,
  previewEvent,
  ghostEvent,
  pointerEvent,
  writable2,
  derived2,
  intl,
  intlRange,
  Calendar_default
};
//# sourceMappingURL=chunk-YWAZIUQ2.js.map
