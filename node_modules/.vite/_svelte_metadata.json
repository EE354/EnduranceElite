{"compilerOptions":{"css":"external","dev":true,"hydratable":true},"configFile":false,"extensions":[".svelte"],"preprocess":[{"script":"async script({ attributes, content, filename = '' }) {\n\t\t\tconst lang = /** @type {string} */ (attributes.lang);\n\t\t\tif (!supportedScriptLangs.includes(lang)) return;\n\t\t\tconst { code, map } = await transformWithEsbuild(content, filename, {\n\t\t\t\tloader: /** @type {import('vite').ESBuildOptions['loader']} */ (lang),\n\t\t\t\ttarget: 'esnext',\n\t\t\t\ttsconfigRaw: {\n\t\t\t\t\tcompilerOptions: {\n\t\t\t\t\t\t// svelte typescript needs this flag to work with type imports\n\t\t\t\t\t\timportsNotUsedAsValues: 'preserve',\n\t\t\t\t\t\tpreserveValueImports: true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmapToRelative(map, filename);\n\n\t\t\treturn {\n\t\t\t\tcode,\n\t\t\t\tmap\n\t\t\t};\n\t\t}","style":"async ({ attributes, content, filename = '' }) => {\n\t\tconst lang = /** @type {string} */ (attributes.lang);\n\t\tif (!supportedStyleLangs.includes(lang)) return;\n\t\tif (!transform) {\n\t\t\t/** @type {import('vite').ResolvedConfig} */\n\t\t\tlet resolvedConfig;\n\t\t\t// @ts-expect-error special prop added if running in v-p-s\n\t\t\tif (style.__resolvedConfig) {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tresolvedConfig = style.__resolvedConfig;\n\t\t\t} else if (isResolvedConfig(config)) {\n\t\t\t\tresolvedConfig = config;\n\t\t\t} else {\n\t\t\t\tresolvedConfig = await resolveConfig(\n\t\t\t\t\tconfig,\n\t\t\t\t\tprocess.env.NODE_ENV === 'production' ? 'build' : 'serve'\n\t\t\t\t);\n\t\t\t}\n\t\t\ttransform = getCssTransformFn(resolvedConfig);\n\t\t}\n\t\tconst suffix = `${lang_sep}${lang}`;\n\t\tconst moduleId = `${filename}${suffix}`;\n\t\tconst { code, map, deps } = await transform(content, moduleId);\n\t\tremoveLangSuffix(map, suffix);\n\t\tmapToRelative(map, filename);\n\t\tconst dependencies = deps ? Array.from(deps).filter((d) => !d.endsWith(suffix)) : undefined;\n\t\treturn {\n\t\t\tcode,\n\t\t\tmap: map ?? undefined,\n\t\t\tdependencies\n\t\t};\n\t}"},{"markup":"markup({ content, filename }) {\n      const s = new MagicString(content)\n      const ast = parse(content, { filename })\n\n      // Import path to import name\n      // e.g. ./foo.png => ___ASSET___0\n      /** @type {Map<string, string>} */\n      const imports = new Map()\n\n      /**\n       * @param {{ raw: string, start: number, end: number }} attributeValue\n       */\n      function addImport(attributeValue) {\n        const url = attributeValue.raw.trim()\n\n        // Skip if url points to id, e.g. sprite sheets\n        if (url.startsWith('#')) return\n\n        if (!http && /^https?:\\/\\//.test(url)) return\n\n        if (urlFilter && !urlFilter(url)) return\n\n        let importName = ''\n\n        if (imports.has(url)) {\n          importName = imports.get(url)\n        } else {\n          importName = importPrefix + imports.size\n          imports.set(url, importName)\n        }\n\n        // e.g. <img src=\"./foo.png\" /> => <img src=\"{___ASSET___0}\" />\n        s.update(attributeValue.start, attributeValue.end, `{${importName}}`)\n      }\n\n      let ignoreNextElement = false\n\n      walk(ast.html, {\n        /**\n         * @param {any} node\n         */\n        enter(node) {\n          if (node.type === 'Comment') {\n            if (node.data.trim() === IGNORE_FLAG) {\n              ignoreNextElement = true\n            }\n          } else if (\n            node.type === 'Element' ||\n            // check component only when have custom sources, as the default object\n            // does not support component names (optimization)\n            (hasCustomSources && node.type === 'InlineComponent')\n          ) {\n            if (ignoreNextElement) {\n              ignoreNextElement = false\n              return\n            }\n\n            /** @type {Record<string, string> | undefined} */\n            let lazyAttributes\n\n            function getAttributes() {\n              if (!lazyAttributes) {\n                lazyAttributes = {}\n                node.attributes.forEach((attr) => {\n                  if (attr.type !== 'Attribute') return\n                  // Ensure text only, since text only attribute values will only have one element\n                  if (attr.value.length > 1 && attr.value[0].type !== 'Text')\n                    return\n                  lazyAttributes[attr.name] = attr.value[0].raw\n                })\n              }\n              return lazyAttributes\n            }\n\n            for (let i = 0; i < sources.length; i++) {\n              /** @type {import('.').AssetSource} */\n              const source = sources[i]\n\n              // Compare node tag match\n              if (source.tag === node.name) {\n                /**\n                 * @param {string} attr\n                 */\n                function getAttrValue(attr) {\n                  const attribute = node.attributes.find(\n                    (v) => v.type === 'Attribute' && v.name === attr\n                  )\n                  if (!attribute) return\n\n                  // Ensure value only consists of one element, and is of type \"Text\".\n                  // Which should only match instances of static `foo=\"bar\"` attributes.\n                  if (\n                    attribute.value.length !== 1 ||\n                    attribute.value[0].type !== 'Text'\n                  )\n                    return\n\n                  if (\n                    source.filter &&\n                    !source.filter({\n                      tag: source.tag,\n                      attribute: attr,\n                      value: attribute.value[0].data,\n                      attributes: getAttributes(),\n                    })\n                  )\n                    return\n\n                  return attribute.value[0]\n                }\n\n                // Check src\n                source.srcAttributes?.forEach((attr) => {\n                  const value = getAttrValue(attr)\n                  if (!value) return\n                  addImport(value)\n                })\n\n                // Check srcset\n                source.srcsetAttributes?.forEach((attr) => {\n                  const value = getAttrValue(attr)\n                  if (!value) return\n                  const srcsetRegex = /\\s*([^,\\s]+).*?(?:,|$)\\s*/gm\n                  let match\n                  while ((match = srcsetRegex.exec(value.raw))) {\n                    addImport({\n                      raw: match[1],\n                      start: value.start + match.index,\n                      end: value.start + match.index + match[1].length,\n                    })\n                  }\n                })\n              }\n            }\n          }\n        },\n      })\n\n      if (imports.size) {\n        let importText = ''\n        for (const [path, importName] of imports.entries()) {\n          importText += `import ${importName} from \"${path}\";`\n        }\n        if (ast.module) {\n          s.appendLeft(ast.module.content.start, importText)\n        } else if (ast.instance) {\n          s.appendLeft(ast.instance.content.start, importText)\n        } else {\n          s.append(`<script>${importText}</script>`)\n        }\n      }\n\n      return {\n        code: s.toString(),\n        map: s.generateMap(),\n      }\n    }"},{"script":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+page.') || basename.startsWith('+layout.')) {\n\t\t\tconst match = content.match(options_regex);\n\t\t\tif (match) {\n\t\t\t\tconst fixed = basename.replace('.svelte', '(.server).js/ts');\n\n\t\t\t\tconst message =\n\t\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t\t`\\`${match[1]}\\` will be ignored — move it to ${fixed} instead. See https://kit.svelte.dev/docs/page-options for more information.`;\n\n\t\t\t\tif (!warned.has(message)) {\n\t\t\t\t\tconsole.log(message);\n\t\t\t\t\twarned.add(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","markup":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+layout.') && !content.includes('<slot')) {\n\t\t\tconst message =\n\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t'`<slot />` missing — inner content will not be rendered';\n\n\t\t\tif (!warned.has(message)) {\n\t\t\t\tconsole.log(message);\n\t\t\t\twarned.add(message);\n\t\t\t}\n\t\t}\n\t}"}]}